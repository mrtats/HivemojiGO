<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Hivemoji Uploader</title>
  <style>
    :root {
      --bg: #0c0f14;
      --panel: #141924;
      --text: #e6edf7;
      --muted: #9da6b8;
      --accent: #4de1b1;
      --border: #1f2634;
      --error: #ff6b6b;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 12px;
      font-family: "Inter", system-ui, -apple-system, sans-serif;
      background: radial-gradient(circle at 20% 20%, rgba(77, 225, 177, 0.12), transparent 45%),
        radial-gradient(circle at 80% 0%, rgba(90, 153, 255, 0.12), transparent 40%),
        var(--bg);
      color: var(--text);
      max-width: 420px;
      margin-inline: auto;
    }
    header { margin-bottom: 10px; }
    .title { font-weight: 700; letter-spacing: 0.4px; }
    .subtitle { color: var(--muted); font-size: 12px; }
    form {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 12px;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.35);
    }
    .field { display: flex; flex-direction: column; gap: 6px; margin-bottom: 10px; }
    label span { font-size: 13px; }
    input, select, button {
      border-radius: 6px;
      border: 1px solid var(--border);
      background: #0f1320;
      color: var(--text);
      padding: 8px;
      font-size: 14px;
    }
    input[type="file"] { padding: 6px; }
    small { color: var(--muted); }
    .inline { display: flex; gap: 12px; margin-bottom: 10px; color: var(--muted); }
    .buttons { display: flex; gap: 8px; margin-top: 6px; flex-wrap: wrap; }
    button {
      cursor: pointer;
      flex: 1;
      background: linear-gradient(135deg, rgba(77, 225, 177, 0.15), rgba(77, 225, 177, 0.02));
      border-color: rgba(77, 225, 177, 0.5);
      transition: border 0.2s ease, transform 0.1s ease;
    }
    button:hover { border-color: var(--accent); }
    button:active { transform: translateY(1px); }
    .code {
      background: #0f1320;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
      max-height: 220px;
      overflow: auto;
      margin-top: 12px;
      font-size: 12px;
      white-space: pre-wrap;
      word-break: break-word;
    }
    #status { margin-top: 8px; font-size: 13px; min-height: 18px; }
    #status.error { color: var(--error); }
    #fileFields.hidden { display: none; }
  </style>
</head>
<body>
  <header>
    <div class="title">Hivemoji</div>
    <div class="subtitle">Build and broadcast custom_json (v1 or chunked v2)</div>
  </header>

  <form id="emojiForm">
    <label class="field">
      <span>Owner account</span>
      <input id="owner" name="owner" placeholder="alice" required />
    </label>

    <label class="field">
      <span>Emoji name</span>
      <input id="name" name="name" placeholder="partyblob" pattern="[a-z0-9_]{1,32}" required />
      <small>Lowercase, digits, underscores; 1-32 chars.</small>
    </label>

    <label class="field">
      <span>Operation</span>
      <select id="operation" name="operation">
        <option value="register">register</option>
        <option value="delete">delete</option>
      </select>
    </label>

    <div id="fileFields">
      <label class="field">
        <span>Emoji file (PNG/WebP/GIF; keep payload under 8 KB for v1)</span>
        <input id="file" name="file" type="file" accept="image/png,image/webp,image/gif" />
      </label>

      <label class="field">
        <span>Fallback (optional static image)</span>
        <input id="fallback" name="fallback" type="file" accept="image/png,image/webp,image/gif" />
      </label>

      <div class="inline">
        <label><input type="checkbox" id="animated" /> Animated</label>
        <label><input type="checkbox" id="loop" /> Loop</label>
      </div>
    </div>

    <div class="buttons">
      <button type="button" id="buildBtn">Build payload</button>
      <button type="button" id="copyBtn">Copy payload</button>
      <button type="submit" id="broadcastBtn">Broadcast via Keychain</button>
    </div>
  </form>

  <pre id="payloadDisplay" class="code"></pre>
  <div id="status"></div>

  <script>
    const PROTOCOL_ID = "hivemoji";
    const PROTOCOL_VERSION = 1;
    const MAX_JSON_BYTES = 8 * 1024; // target size for v1 before chunking
    const MAX_CHUNK_DATA_BYTES = 4 * 1024;
    const MAX_TOTAL_BYTES = 100 * 1024;
    const MAX_CHUNKS = 50;

    const form = document.getElementById("emojiForm");
    const opSelect = document.getElementById("operation");
    const fileFields = document.getElementById("fileFields");
    const statusEl = document.getElementById("status");
    const payloadDisplay = document.getElementById("payloadDisplay");

    opSelect.addEventListener("change", () => {
      const isDelete = opSelect.value === "delete";
      fileFields.classList.toggle("hidden", isDelete);
    });

    function setStatus(msg, isError = false) {
      statusEl.textContent = msg || "";
      statusEl.classList.toggle("error", isError);
    }

    function validateName(name) {
      if (!/^[a-z0-9_]{1,32}$/.test(name)) {
        throw new Error("Name must be [a-z0-9_], 1-32 chars");
      }
    }

    function jsonSizeBytes(obj) {
      return new TextEncoder().encode(typeof obj === "string" ? obj : JSON.stringify(obj)).length;
    }

    function bufferToBase64(buf) {
      let binary = "";
      const bytes = new Uint8Array(buf);
      const chunkSize = 0x8000;
      for (let i = 0; i < bytes.length; i += chunkSize) {
        binary += String.fromCharCode(...bytes.subarray(i, i + chunkSize));
      }
      return btoa(binary);
    }

    async function readImage(file) {
      const buf = await file.arrayBuffer();
      const dataUrl = await new Promise((resolve, reject) => {
        const fr = new FileReader();
        fr.onload = () => resolve(fr.result);
        fr.onerror = () => reject(fr.error);
        fr.readAsDataURL(file);
      });
      const dims = await new Promise((resolve) => {
        const img = new Image();
        img.onload = () => resolve({ width: img.naturalWidth, height: img.naturalHeight });
        img.onerror = () => resolve({ width: 0, height: 0 });
        img.src = dataUrl;
      });
      return {
        buffer: new Uint8Array(buf),
        data: bufferToBase64(buf),
        mime: file.type || "image/webp",
        width: dims.width,
        height: dims.height,
      };
    }

    function makeEnvelope(owner, payloadJson) {
      return [
        "custom_json",
        {
          id: PROTOCOL_ID,
          json: payloadJson,
          required_auths: [],
          required_posting_auths: owner ? [owner] : [],
        },
      ];
    }

    async function chunkImage(img, name, animated, loop, kind = "main") {
      if (img.buffer.length > MAX_TOTAL_BYTES) {
        throw new Error(`Image too large (${img.buffer.length} bytes > ${MAX_TOTAL_BYTES})`);
      }
      const total = Math.ceil(img.buffer.length / MAX_CHUNK_DATA_BYTES);
      if (total > MAX_CHUNKS) {
        throw new Error(`Too many chunks (${total} > ${MAX_CHUNKS})`);
      }

      let checksumHex;
      try {
        const digest = await crypto.subtle.digest("SHA-256", img.buffer);
        checksumHex = Array.from(new Uint8Array(digest)).map((b) => b.toString(16).padStart(2, "0")).join("");
      } catch {
        checksumHex = undefined;
      }

      const chunks = [];
      for (let i = 0; i < total; i++) {
        const slice = img.buffer.subarray(i * MAX_CHUNK_DATA_BYTES, (i + 1) * MAX_CHUNK_DATA_BYTES);
        chunks.push({
          version: 2,
          op: "chunk",
          id: "", // fill later
          name,
          mime: img.mime,
          width: img.width,
          height: img.height,
          animated,
          loop,
          seq: i + 1,
          total,
          data: bufferToBase64(slice),
          kind,
          checksum: checksumHex,
        });
      }
      return chunks;
    }

    async function buildPayloads() {
      const owner = document.getElementById("owner").value.trim();
      const name = document.getElementById("name").value.trim();
      const op = opSelect.value;

      if (!owner) throw new Error("Owner is required");
      validateName(name);

      if (op === "delete") {
        const payload = { op: "delete", version: PROTOCOL_VERSION, name };
        return { payloads: [payload], owner };
      }

      const file = document.getElementById("file").files[0];
      if (!file) throw new Error("Select an emoji file");
      const main = await readImage(file);
      const fallbackFile = document.getElementById("fallback").files[0];
      const fallback = fallbackFile ? await readImage(fallbackFile) : null;

      const animated = document.getElementById("animated").checked || undefined;
      const loop = document.getElementById("loop").checked ? 0 : undefined;

      const basePayload = {
        op: "register",
        version: PROTOCOL_VERSION,
        name,
        mime: main.mime,
        width: main.width,
        height: main.height,
        data: main.data,
      };
      if (animated !== undefined) basePayload.animated = animated;
      if (loop !== undefined) basePayload.loop = loop;
      if (fallback) {
        basePayload.fallback = { mime: fallback.mime, data: fallback.data };
      }

      if (jsonSizeBytes(basePayload) <= MAX_JSON_BYTES) {
        return { payloads: [basePayload], owner };
      }

      // chunked v2
      const uploadId = `${name}-${Date.now().toString(16)}-${Math.random().toString(16).slice(2)}`;
      const mainChunks = await chunkImage(main, name, animated, loop, "main");
      const fbChunks = fallback ? await chunkImage(fallback, name, animated, loop, "fallback") : [];
      [...mainChunks, ...fbChunks].forEach((c) => (c.id = uploadId));

      const manifest = {
        version: 2,
        op: "register",
        name,
        mime: main.mime,
        width: main.width,
        height: main.height,
        animated,
        loop,
        chunked: true,
        id: uploadId,
        main_total: mainChunks.length,
        fallback_total: fbChunks.length || undefined,
      };

      return { payloads: [...mainChunks, ...fbChunks, manifest], owner };
    }

    function renderPayload(payloads) {
      if (!payloads || payloads.length === 0) {
        payloadDisplay.textContent = "";
        return;
      }
      if (payloads.length === 1) {
        payloadDisplay.textContent = JSON.stringify(payloads[0], null, 2);
        return;
      }
      payloadDisplay.textContent = payloads
        .map((p, i) => `#${i + 1}/${payloads.length}\n${JSON.stringify(p, null, 2)}`)
        .join("\n\n");
    }

    async function handleBuild() {
      try {
        setStatus("Building...");
        const { payloads } = await buildPayloads();
        renderPayload(payloads);
        setStatus(
          payloads.length === 1
            ? "v1 payload ready (fits <=8 KB)."
            : `Chunked v2 payload ready (${payloads.length} messages).`
        );
      } catch (err) {
        setStatus(err.message || String(err), true);
      }
    }

    async function handleCopy() {
      const text = payloadDisplay.textContent.trim();
      if (!text) return;
      await navigator.clipboard.writeText(text);
      setStatus("Copied payload preview.");
    }

    async function broadcastViaKeychain(payloads, owner) {
      if (!window.hive_keychain) {
        throw new Error("hive_keychain not found in this page.");
      }
      for (let i = 0; i < payloads.length; i++) {
        const json = JSON.stringify(payloads[i]);
        const title = `Hivemoji ${payloads[i].op || "chunk"} :${payloads[i].name}: (${i + 1}/${payloads.length})`;
        await new Promise((resolve, reject) => {
          window.hive_keychain.requestCustomJson(
            owner,
            PROTOCOL_ID,
            "Posting",
            json,
            title,
            (res) => {
              if (res && res.success) return resolve(res);
              reject(new Error(res && res.message ? res.message : "Keychain rejected"));
            }
          );
        });
        setStatus(`Broadcasted ${i + 1}/${payloads.length}...`);
      }
      setStatus("All broadcasts sent. Check hive-keychain for confirmation.");
    }

    form.addEventListener("submit", async (e) => {
      e.preventDefault();
      try {
        setStatus("Building...");
        const { payloads, owner } = await buildPayloads();
        renderPayload(payloads);
        setStatus("Requesting hive-keychain...");
        await broadcastViaKeychain(payloads, owner);
      } catch (err) {
        setStatus(err.message || String(err), true);
      }
    });

    document.getElementById("buildBtn").addEventListener("click", handleBuild);
    document.getElementById("copyBtn").addEventListener("click", handleCopy);
  </script>
</body>
</html>
